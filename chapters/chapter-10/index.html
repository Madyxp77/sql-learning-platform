<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 10: Advanced SQL Techniques - The SQL Path</title>
    <!-- Favicon placeholder -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3EðŸ“Š%3C/text%3E%3C/svg%3E" />
    <!-- Main stylesheet for general layout and responsiveness -->
    <link rel="stylesheet" href="../../assets/css/style.css">
    <!-- Theme stylesheet for dark/light mode variables and transitions -->
    <link rel="stylesheet" href="../../assets/css/theme.css">
    <!-- Google Fonts - Inter for clean typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Chapter-specific styles for better content presentation (replicated from previous chapters for consistency) */
        .chapter-container {
            padding-top: 2rem;
            padding-bottom: 2rem;
        }

        .breadcrumbs {
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            color: var(--nav-link-color);
        }

        .breadcrumbs a {
            color: var(--nav-link-color);
            text-decoration: none;
        }

        .breadcrumbs a:hover {
            text-decoration: underline;
        }

        .breadcrumbs span {
            font-weight: 600;
            color: var(--primary-color);
        }

        .chapter-title {
            font-size: 2.8rem;
            margin-bottom: 0.8rem;
            color: var(--heading-color);
        }

        .chapter-intro {
            font-size: 1.15rem;
            color: var(--text-color);
            margin-bottom: 2rem;
            max-width: 850px;
            line-height: 1.7;
        }

        .chapter-section {
            background-color: var(--card-bg-color);
            padding: 2rem;
            border-radius: var(--border-radius-lg);
            box-shadow: var(--card-shadow);
            margin-bottom: 2.5rem;
        }

        .chapter-section h2 {
            font-size: 2rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .chapter-section h3 {
            font-size: 1.6rem;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
            color: var(--heading-color);
        }

        .chapter-section p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }

        .code-block-container {
            margin-top: 1.5rem;
            margin-bottom: 2rem;
            background-color: var(--code-bg-color);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--code-border-color);
            overflow: hidden;
        }

        .code-editor {
            height: 200px; /* Default height for the Monaco editor */
            width: 100%;
            border-bottom: 1px solid var(--code-border-color);
        }

        .editor-actions {
            padding: 0.8rem;
            display: flex;
            gap: 1rem;
            justify-content: flex-start;
            align-items: center;
        }

        .query-results {
            background-color: var(--content-bg-color);
            border-top: 1px solid var(--border-color);
            padding: 1rem;
            min-height: 50px;
            max-height: 300px;
            overflow: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            color: var(--text-color);
            border-bottom-left-radius: var(--border-radius-md);
            border-bottom-right-radius: var(--border-radius-md);
        }

        .query-results table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.5rem;
        }

        .query-results th, .query-results td {
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            text-align: left;
        }

        .query-results th {
            background-color: var(--primary-color);
            color: var(--button-text-color);
            font-weight: 600;
        }

        .exercise-section {
            margin-top: 3rem;
            background-color: var(--card-bg-color);
            padding: 2rem;
            border-radius: var(--border-radius-lg);
            box-shadow: var(--card-shadow);
        }

        .exercise-section h2 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .exercise-item {
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            background-color: var(--background-color); /* Lighter background for exercises */
        }

        .exercise-item h3 {
            margin-top: 0;
            color: var(--heading-color);
            font-size: 1.3rem;
        }

        .exercise-item p {
            margin-bottom: 1rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .chapter-title {
                font-size: 2rem;
            }
            .chapter-intro {
                font-size: 1rem;
            }
            .chapter-section {
                padding: 1.5rem;
            }
            .chapter-section h2 {
                font-size: 1.8rem;
            }
            .chapter-section h3 {
                font-size: 1.4rem;
            }
            .editor-actions {
                flex-direction: column;
                align-items: stretch;
                gap: 0.8rem;
            }
            .editor-actions .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <header class="main-header">
        <div class="container header-content">
            <div class="logo">
                <a href="../../index.html">The SQL Path</a>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="../../index.html#chapters">Chapters</a></li>
                    <li><a href="../../index.html#about">About</a></li>
                    <li><a href="../../index.html#contact">Contact</a></li>
                </ul>
            </nav>
            <div class="theme-toggle-container">
                <button id="theme-toggle" aria-label="Toggle dark/light theme">
                    <!-- Icon for theme toggle - will be set by JavaScript -->
                    <span class="icon">ðŸ’¡</span>
                </button>
            </div>
        </div>
    </header>

    <main class="chapter-main">
        <div class="container chapter-container">
            <nav class="breadcrumbs">
                <a href="../../index.html">Home</a> &gt; <a href="../../index.html#chapters">Chapters</a> &gt; <span>Chapter 10</span>
            </nav>

            <h1 class="chapter-title">Chapter 10: Advanced SQL Techniques for Complex Analysis</h1>
            <p class="chapter-intro">You've built a solid foundation in SQL, covering essential commands, filtering, grouping, joining, and even basic subqueries and window functions. Now, it's time to put all those pieces together and tackle more intricate analytical problems. This chapter will focus on combining various SQL concepts to derive deeper insights and solve challenging data scenarios.</p>

            <section class="chapter-section">
                <h2>10.1 Mastering CTEs for Multi-Step Analysis</h2>
                <p>Common Table Expressions (CTEs) are not just about readability; they enable multi-step data transformations within a single query. You can build up complex datasets iteratively, with each CTE serving as an intermediate, reusable result set.</p>
                <p>Let's calculate the total spending for each customer, and then use that information in a subsequent CTE to find the average order value for customers who belong to a specific spending tier (e.g., 'High Spenders' if total spent is over $500, 'Regular' otherwise).</p>
                <div class="code-block-container">
                    <div id="editor-10-1" class="code-editor"></div>
                    <div class="editor-actions">
                        <button class="btn btn-primary run-query-btn" data-editor-id="editor-10-1">Run Query</button>
                    </div>
                    <div class="query-results" id="results-10-1">
                        <p>Results will appear here.</p>
                    </div>
                </div>
                <p>This example demonstrates how `CustomerSpend` calculates the total for each customer, and then `TieredCustomers` categorizes them. Finally, the outer query aggregates based on the tier.</p>
            </section>

            <section class="chapter-section">
                <h2>10.2 Subquery Scenarios: Correlated vs. Non-Correlated Revisited</h2>
                <p>Understanding when to use correlated versus non-correlated subqueries is key to writing efficient and correct queries. While joins and window functions often provide more performant alternatives, subqueries remain a fundamental tool.</p>
                <p>Let's find all products whose price is higher than the overall average price of ALL products and whose `stock_quantity` is currently below 50. This combines a non-correlated subquery for the average and a simple filter.</p>
                <div class="code-block-container">
                    <div id="editor-10-2" class="code-editor"></div>
                    <div class="editor-actions">
                        <button class="btn btn-primary run-query-btn" data-editor-id="editor-10-2">Run Query</button>
                    </div>
                    <div class="query-results" id="results-10-2">
                        <p>Results will appear here.</p>
                    </div>
                </div>
                <p>Now, let's try a more complex correlated subquery: find orders where the `total_amount` is greater than the average `total_amount` of orders placed by the *same customer* in the *same month* as the current order.</p>
                <div class="code-block-container">
                    <div id="editor-10-3" class="code-editor"></div>
                    <div class="editor-actions">
                        <button class="btn btn-primary run-query-btn" data-editor-id="editor-10-3">Run Query</button>
                    </div>
                    <div class="query-results" id="results-10-3">
                        <p>Results will appear here.</p>
                    </div>
                </div>
            </section>

            <section class="chapter-section">
                <h2>10.3 Power of Window Functions: Cumulative and Moving Aggregates</h2>
                <p>Window functions truly shine when performing calculations over a rolling or cumulative period, providing context to individual rows within a group. The `ROWS` or `RANGE` frame clauses allow precise control over which rows are included in the "window" for each calculation.</p>
                <p>Let's calculate the cumulative sum of `total_amount` for each customer, ordered by `order_date`. This shows how much a customer has spent up to each given order.</p>
                <div class="code-block-container">
                    <div id="editor-10-4" class="code-editor"></div>
                    <div class="editor-actions">
                        <button class="btn btn-primary run-query-btn" data-editor-id="editor-10-4">Run Query</button>
                    </div>
                    <div class="query-results" id="results-10-4">
                        <p>Results will appear here.</p>
                    </div>
                </div>
                <p>Now, calculate a 2-order moving average of `total_amount` for each customer. This averages the current order's amount with the previous one, giving a smoother trend line.</p>
                <div class="code-block-container">
                    <div id="editor-10-5" class="code-editor"></div>
                    <div class="editor-actions">
                        <button class="btn btn-primary run-query-btn" data-editor-id="editor-10-5">Run Query</button>
                    </div>
                    <div class="query-results" id="results-10-5">
                        <p>Results will appear here.</p>
                    </div>
                </div>
            </section>

            <section class="exercise-section">
                <h2>Chapter 10 Exercises</h2>
                <p>Tackle these comprehensive exercises, leveraging multiple advanced SQL techniques to solve real-world data analysis problems.</p>

                <div class="exercise-item" data-exercise-id="chapter-10-exercise-10-1">
                    <h3>Exercise 10.1: Top 3 Products by Total Sales per Category</h3>
                    <p>For each product `category`, identify the top 3 `product_name`s based on their `total_sales_amount` (calculated by `SUM(quantity * item_price)` from `OrderItems`). Display `category`, `product_name`, `total_sales_amount`, and their `rank_in_category`. Use CTEs and/or Window Functions to achieve this. Order the final results by `category` and `rank_in_category`.</p>
                    <div class="code-block-container">
                        <div id="exercise-editor-10-1" class="code-editor"></div>
                        <div class="editor-actions">
                            <button class="btn btn-primary run-query-btn" data-editor-id="exercise-editor-10-1">Run Query</button>
                            <button class="btn btn-secondary check-answer-btn" data-exercise-id="chapter-10-exercise-10-1">Check Answer</button>
                        </div>
                        <div class="query-results" id="exercise-results-10-1">
                            <p>Results and feedback will appear here.</p>
                        </div>
                    </div>
                </div>

                <div class="exercise-item" data-exercise-id="chapter-10-exercise-10-2">
                    <h3>Exercise 10.2: Monthly New Customer Count and Cumulative Customers</h3>
                    <p>Calculate the number of new customers who registered each month. Then, using a window function, calculate the cumulative count of customers over time. Display `registration_month` (e.g., '2022-01'), `new_customers_count`, and `cumulative_customers`. Order the results chronologically.</p>
                    <div class="code-block-container">
                        <div id="exercise-editor-10-2" class="code-editor"></div>
                        <div class="editor-actions">
                            <button class="btn btn-primary run-query-btn" data-editor-id="exercise-editor-10-2">Run Query</button>
                            <button class="btn btn-secondary check-answer-btn" data-exercise-id="chapter-10-exercise-10-2">Check Answer</button>
                        </div>
                        <div class="query-results" id="exercise-results-10-2">
                            <p>Results and feedback will appear here.</p>
                        </div>
                    </div>
                </div>

                <div class="exercise-item" data-exercise-id="chapter-10-exercise-10-3">
                    <h3>Exercise 10.3: Customer's First and Last Order Dates</h3>
                    <p>For each customer, find their first order date and their last order date. Display `customer_id`, `first_name`, `last_name`, `first_order_date`, and `last_order_date`. (Hint: You can achieve this using aggregate functions with `GROUP BY` on customers and then join back to the customer table, or use window functions.)</p>
                    <div class="code-block-container">
                        <div id="exercise-editor-10-3" class="code-editor"></div>
                        <div class="editor-actions">
                            <button class="btn btn-primary run-query-btn" data-editor-id="exercise-editor-10-3">Run Query</button>
                            <button class="btn btn-secondary check-answer-btn" data-exercise-id="chapter-10-exercise-10-3">Check Answer</button>
                        </div>
                        <div class="query-results" id="exercise-results-10-3">
                            <p>Results and feedback will appear here.</p>
                        </div>
                    </div>
                </div>
            </section>

        </div>
    </main>

    <footer class="main-footer">
        <div class="container">
            <p>&copy; <span id="current-year"></span> The SQL Path. All rights reserved.</p>
            <div class="footer-links">
                <a href="#">Privacy Policy</a>
                <a href="#">Terms of Service</a>
            </div>
        </div>
    </footer>

    <!-- Global scripts: main.js handles theme toggle, etc. -->
    <script type="module" src="../../assets/js/main.js"></script>

    <!-- Chapter-specific scripts for SQL Editor and Database interaction -->
    <script type="module">
        import { loadMonacoEditor, initializeMonacoEditor, getEditorContent, setEditorContent } from '../../assets/js/code-editor.js';
        import { initializeDatabase, executeSql } from '../../assets/js/sql-engine.js';
        import { setExerciseCompleted, isExerciseCompleted } from '../../assets/js/progress-tracking.js';
        import { getElementById, createElement, emptyElement } from '../../assets/js/utils.js';

        // Initial SQL content for the demonstration editors
        const initialQuery10_1 = `WITH CustomerSpend AS (
    SELECT
        customer_id,
        SUM(total_amount) AS total_spent
    FROM Orders
    GROUP BY customer_id
),
TieredCustomers AS (
    SELECT
        cs.customer_id,
        c.first_name,
        c.last_name,
        cs.total_spent,
        CASE
            WHEN cs.total_spent > 500 THEN 'High Spender'
            ELSE 'Regular'
        END AS spending_tier
    FROM CustomerSpend cs
    JOIN Customers c ON cs.customer_id = c.customer_id
)
SELECT
    spending_tier,
    AVG(total_spent) AS average_spend_in_tier
FROM TieredCustomers
GROUP BY spending_tier
ORDER BY average_spend_in_tier DESC;`;

        const initialQuery10_2 = `SELECT
    product_name,
    price,
    stock_quantity
FROM Products
WHERE price > (SELECT AVG(price) FROM Products) AND stock_quantity < 50
ORDER BY price DESC;`;

        const initialQuery10_3 = `SELECT
    o1.order_id,
    o1.customer_id,
    o1.order_date,
    o1.total_amount
FROM Orders o1
WHERE o1.total_amount > (
    SELECT AVG(o2.total_amount)
    FROM Orders o2
    WHERE o2.customer_id = o1.customer_id
      AND STRFTIME('%Y-%m', o2.order_date) = STRFTIME('%Y-%m', o1.order_date)
)
ORDER BY o1.customer_id, o1.order_date;`;

        const initialQuery10_4 = `SELECT
    customer_id,
    order_id,
    order_date,
    total_amount,
    SUM(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS cumulative_customer_spend
FROM Orders
ORDER BY customer_id, order_date;`;

        const initialQuery10_5 = `SELECT
    customer_id,
    order_id,
    order_date,
    total_amount,
    AVG(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS two_order_moving_avg
FROM Orders
ORDER BY customer_id, order_date;`;


        // Initial SQL content for exercises
        const initialExercise10_1 = `WITH ProductSales AS (
    SELECT
        p.category,
        p.product_name,
        SUM(oi.quantity * oi.item_price) AS total_sales_amount
    FROM Products p
    JOIN OrderItems oi ON p.product_id = oi.product_id
    GROUP BY p.category, p.product_name
),
RankedProductSales AS (
    SELECT
        category,
        product_name,
        total_sales_amount,
        ROW_NUMBER() OVER (PARTITION BY category ORDER BY total_sales_amount DESC) AS rank_in_category
    FROM ProductSales
)
SELECT
    category,
    product_name,
    total_sales_amount,
    rank_in_category
FROM RankedProductSales
WHERE rank_in_category <= 3
ORDER BY category ASC, rank_in_category ASC;`;

        const initialExercise10_2 = `WITH MonthlyRegistrations AS (
    SELECT
        STRFTIME('%Y-%m', registration_date) AS registration_month,
        COUNT(customer_id) AS new_customers_count
    FROM Customers
    GROUP BY registration_month
)
SELECT
    registration_month,
    new_customers_count,
    SUM(new_customers_count) OVER (ORDER BY registration_month) AS cumulative_customers
FROM MonthlyRegistrations
ORDER BY registration_month ASC;`;

        const initialExercise10_3 = `SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    MIN(o.order_date) AS first_order_date,
    MAX(o.order_date) AS last_order_date
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY c.customer_id ASC;`;


        // Keep track of editors
        const editors = {};

        /**
         * Renders query results in a table format.
         * (Same as previous chapters, ensuring consistency)
         */
        function renderResults(resultsContainer, columns, rows) {
            emptyElement(resultsContainer); // Clear previous results

            if (!columns || columns.length === 0) {
                resultsContainer.appendChild(createElement('p', { textContent: 'Query executed successfully. No columns returned.' }));
                return;
            }
            if (!rows || rows.length === 0) {
                resultsContainer.appendChild(createElement('p', { textContent: 'Query executed successfully. No rows returned.' }));
                return;
            }

            const table = createElement('table');
            const thead = createElement('thead');
            const tbody = createElement('tbody');

            // Create table header
            const headerRow = createElement('tr');
            columns.forEach(col => {
                headerRow.appendChild(createElement('th', { textContent: col }));
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            rows.forEach(rowData => {
                const row = createElement('tr');
                rowData.forEach(cellData => {
                    // Handle NULL values, format numbers if needed (e.g., for rounded percentages or currency)
                    let displayData = cellData;
                    if (cellData === null) {
                        displayData = 'NULL';
                    } else if (typeof cellData === 'number' && !Number.isInteger(cellData)) {
                        // Round numbers to 2 decimal places for display consistency
                        displayData = cellData.toFixed(2);
                    }
                    row.appendChild(createElement('td', { textContent: displayData.toString() }));
                });
                tbody.appendChild(row);
            });
            table.appendChild(tbody);

            resultsContainer.appendChild(table);
        }

        /**
         * Displays a message in the results container.
         * (Same as previous chapters, ensuring consistency)
         */
        function displayMessage(resultsContainer, message, isError = false) {
            emptyElement(resultsContainer);
            const p = createElement('p', { textContent: message });
            if (isError) {
                p.style.color = 'var(--primary-color)';
                p.style.fontWeight = 'bold';
            }
            resultsContainer.appendChild(p);
        }

        /**
         * Handles the execution of a SQL query from an editor.
         * (Same as previous chapters, ensuring consistency)
         */
        async function handleRunQuery(editorId, resultsId) {
            const editor = editors[editorId];
            const resultsContainer = getElementById(resultsId);

            if (!editor || !resultsContainer) {
                console.error(`Editor (${editorId}) or results container (${resultsId}) not found.`);
                return;
            }

            const query = editor.getValue();
            if (!query.trim()) {
                displayMessage(resultsContainer, 'Please enter a SQL query to execute.', true);
                return;
            }

            displayMessage(resultsContainer, 'Executing query...', false);

            try {
                const result = executeSql(query);

                if (result.error) {
                    displayMessage(resultsContainer, `Error: ${result.error}`, true);
                } else if (result.isSelect) {
                    renderResults(resultsContainer, result.columns, result.rows);
                } else {
                    displayMessage(resultsContainer, result.message || 'Command executed successfully.', false);
                }
            } catch (e) {
                console.error('Unexpected error during query execution:', e);
                displayMessage(resultsContainer, `An unexpected error occurred: ${e.message}`, true);
            }
        }

        /**
         * Initializes an individual editor and sets up its run button.
         * (Same as previous chapters, ensuring consistency)
         */
        function setupEditorAndRunButton(editorId, initialContent, resultsId) {
            const editorDiv = getElementById(editorId);
            if (editorDiv) {
                editors[editorId] = initializeMonacoEditor(editorId, initialContent, document.documentElement.getAttribute('data-theme') === 'dark' ? 'vs-dark' : 'vs-light');

                const runButton = document.querySelector(`button.run-query-btn[data-editor-id="${editorId}"]`);
                if (runButton) {
                    runButton.addEventListener('click', () => handleRunQuery(editorId, resultsId));
                }
            }
        }

        /**
         * Sets up the theme change listener for all editors.
         * (Same as previous chapters, ensuring consistency)
         */
        function setupEditorThemeListener() {
            const htmlElement = document.documentElement;
            const observer = new MutationObserver((mutations) => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
                        const newTheme = htmlElement.getAttribute('data-theme') === 'dark' ? 'vs-dark' : 'vs-light';
                        for (const editorId in editors) {
                            if (editors[editorId]) {
                                editors[editorId].updateOptions({ theme: newTheme });
                            }
                        }
                    }
                });
            });
            observer.observe(htmlElement, { attributes: true });
        }

        /**
         * Compares two 2D arrays (results from SQL queries).
         * This version is specifically tuned for window functions where both column and row order are crucial.
         * It also handles potential floating point differences by rounding.
         * @param {Array<string>} userColumns User's query columns.
         * @param {Array<Array<any>>} userRows User's query rows.
         * @param {Array<string>} expectedColumns Expected query columns.
         * @param {Array<Array<any>>} expectedRows Expected query rows.
         * @returns {boolean} True if results match, false otherwise.
         */
        function compareQueryResults(userColumns, userRows, expectedColumns, expectedRows) {
            // 1. Check column count and names (order matters for window functions typically)
            if (userColumns.length !== expectedColumns.length) {
                console.log("Column count mismatch.");
                return false;
            }
            if (JSON.stringify(userColumns) !== JSON.stringify(expectedColumns)) {
                console.log("Column names or their order mismatch.");
                return false;
            }

            // 2. Check row count
            if (userRows.length !== expectedRows.length) {
                console.log(`Row count mismatch. Expected ${expectedRows.length}, got ${userRows.length}.`);
                return false;
            }

            // 3. Deep compare rows, handling potential floating point differences and NULLs
            for (let r = 0; r < userRows.length; r++) {
                if (userRows[r].length !== expectedRows[r].length) {
                    console.log(`Cell count mismatch in row ${r}.`);
                    return false;
                }
                for (let c = 0; c < userRows[r].length; c++) {
                    const userCell = userRows[r][c];
                    const expectedCell = expectedRows[r][c];

                    // Handle NULLs
                    if (userCell === null && expectedCell === null) {
                        continue; // Both are NULL, consider them equal
                    }
                    if (userCell === null || expectedCell === null) {
                        console.log(`NULL mismatch at row ${r}, col ${c}.`);
                        return false; // One is NULL, other is not
                    }

                    // For numbers, compare with a tolerance for floating-point inaccuracies
                    // Also consider parsing numbers from strings if they are formatted differently
                    let numUser = typeof userCell === 'number' ? userCell : parseFloat(userCell);
                    let numExpected = typeof expectedCell === 'number' ? expectedCell : parseFloat(expectedCell);

                    if (!isNaN(numUser) && !isNaN(numExpected)) { // If both are valid numbers
                        if (Math.abs(numUser - numExpected) > 0.01) { // Tolerance adjusted slightly for currency/percentages
                            console.log(`Numeric mismatch at row ${r}, col ${c}. User: ${userCell}, Expected: ${expectedCell}`);
                            return false;
                        }
                    } else if (String(userCell) !== String(expectedCell)) {
                        // For other types (or non-numeric strings), direct string comparison
                        console.log(`Value mismatch at row ${r}, col ${c}. User: ${String(userCell)}, Expected: ${String(expectedCell)}`);
                        return false;
                    }
                }
            }

            return true;
        }


        /**
         * Handles the "Check Answer" functionality for exercises.
         * @param {string} exerciseId The unique ID of the exercise.
         * @param {string} editorId The ID of the associated editor.
         * @param {string} resultsId The ID of the associated results container.
         * @param {string} expectedQuery The correct SQL query for validation.
         * @param {boolean} [requiresSelect=true] If true, validates only SELECT queries.
         */
        async function handleCheckAnswer(exerciseId, editorId, resultsId, expectedQuery, requiresSelect = true) {
            const editor = editors[editorId];
            const resultsContainer = getElementById(resultsId);
            const exerciseItemElement = getElementById(exerciseId);

            if (!editor || !resultsContainer || !exerciseItemElement) {
                console.error(`Elements for exercise check not found: Editor(${editorId}), Results(${resultsId}), Item(${exerciseId}).`);
                return;
            }

            const userQuery = editor.getValue();
            if (!userQuery.trim()) {
                displayMessage(resultsContainer, 'Please write your query before checking the answer.', true);
                setExerciseCompleted(exerciseId, false);
                exerciseItemElement.style.border = '1px solid var(--border-color)';
                return;
            }

            displayMessage(resultsContainer, 'Checking your answer...', false);

            try {
                const userResult = executeSql(userQuery);

                if (userResult.error) {
                    displayMessage(resultsContainer, `Your query has an error: ${userResult.error}`, true);
                    setExerciseCompleted(exerciseId, false);
                    exerciseItemElement.style.border = '1px solid var(--border-color)';
                    return;
                }

                if (requiresSelect && !userResult.isSelect) {
                    displayMessage(resultsContainer, 'Please provide a SELECT query to check your answer.', true);
                    setExerciseCompleted(exerciseId, false);
                    exerciseItemElement.style.border = '1px solid var(--border-color)';
                    return;
                }

                const expectedResult = executeSql(expectedQuery);

                if (expectedResult.error) {
                    console.error('Error in expected query for exercise validation:', expectedResult.error);
                    displayMessage(resultsContainer, 'An internal error occurred while validating the exercise. Please try again later.', true);
                    setExerciseCompleted(exerciseId, false);
                    exerciseItemElement.style.border = '1px solid var(--border-color)';
                    return;
                }

                let isCorrect = false;
                if (requiresSelect) {
                    isCorrect = compareQueryResults(userResult.columns, userResult.rows, expectedResult.columns, expectedResult.rows);
                } else {
                    isCorrect = !userResult.error;
                }

                if (isCorrect) {
                    displayMessage(resultsContainer, 'ðŸŽ‰ Correct! Well done!', false);
                    setExerciseCompleted('chapter-10', exerciseId, true); // Mark as completed for chapter 10
                    exerciseItemElement.style.border = '2px solid var(--primary-color)'; // Visual feedback
                } else {
                    displayMessage(resultsContainer, 'âŒ Incorrect. Review your query and try again.', true);
                    setExerciseCompleted('chapter-10', exerciseId, false);
                    exerciseItemElement.style.border = '1px solid var(--border-color)'; // Reset border
                }

                renderResults(resultsContainer, userResult.columns, userResult.rows);

            } catch (e) {
                console.error('Error during exercise check:', e);
                displayMessage(resultsContainer, `An unexpected error occurred during check: ${e.message}`, true);
                setExerciseCompleted('chapter-10', exerciseId, false);
                exerciseItemElement.style.border = '1px solid var(--border-color)';
            }
        }


        // DOM Content Loaded Handler
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Chapter 10: DOM Content Loaded.');

            // Initialize the database for this chapter
            try {
                await initializeDatabase();
            } catch (e) {
                console.error("Failed to initialize database for Chapter 10:", e);
                displayMessage(getElementById('results-10-1'), `Failed to load database: ${e.message}. Interactive exercises might not work.`, true);
                return;
            }

            // Load Monaco Editor
            try {
                await loadMonacoEditor();
            } catch (e) {
                console.error("Failed to load Monaco Editor for Chapter 10:", e);
                displayMessage(getElementById('results-10-1'), `Failed to load code editor: ${e.message}. Code interaction will not work.`, true);
                return;
            }

            // Set up demonstration editors
            setupEditorAndRunButton('editor-10-1', initialQuery10_1, 'results-10-1');
            setupEditorAndRunButton('editor-10-2', initialQuery10_2, 'results-10-2');
            setupEditorAndRunButton('editor-10-3', initialQuery10_3, 'results-10-3');
            setupEditorAndRunButton('editor-10-4', initialQuery10_4, 'results-10-4');
            setupEditorAndRunButton('editor-10-5', initialQuery10_5, 'results-10-5');


            // Set up exercise editors and their check buttons
            setupEditorAndRunButton('exercise-editor-10-1', initialExercise10_1, 'exercise-results-10-1');
            const checkBtn10_1 = document.querySelector('button.check-answer-btn[data-exercise-id="chapter-10-exercise-10-1"]');
            if (checkBtn10_1) {
                checkBtn10_1.addEventListener('click', () => handleCheckAnswer(
                    'chapter-10-exercise-10-1',
                    'exercise-editor-10-1',
                    'exercise-results-10-1',
                    `WITH ProductSales AS (
    SELECT
        p.category,
        p.product_name,
        SUM(oi.quantity * oi.item_price) AS total_sales_amount
    FROM Products p
    JOIN OrderItems oi ON p.product_id = oi.product_id
    GROUP BY p.category, p.product_name
),
RankedProductSales AS (
    SELECT
        category,
        product_name,
        total_sales_amount,
        ROW_NUMBER() OVER (PARTITION BY category ORDER BY total_sales_amount DESC) AS rank_in_category
    FROM ProductSales
)
SELECT
    category,
    product_name,
    total_sales_amount,
    rank_in_category
FROM RankedProductSales
WHERE rank_in_category <= 3
ORDER BY category ASC, rank_in_category ASC;`
                ));
                if (isExerciseCompleted('chapter-10', 'chapter-10-exercise-10-1')) {
                    getElementById('chapter-10-exercise-10-1').style.border = '2px solid var(--primary-color)';
                }
            }

            setupEditorAndRunButton('exercise-editor-10-2', initialExercise10_2, 'exercise-results-10-2');
            const checkBtn10_2 = document.querySelector('button.check-answer-btn[data-exercise-id="chapter-10-exercise-10-2"]');
            if (checkBtn10_2) {
                checkBtn10_2.addEventListener('click', () => handleCheckAnswer(
                    'chapter-10-exercise-10-2',
                    'exercise-editor-10-2',
                    'exercise-results-10-2',
                    `WITH MonthlyRegistrations AS (
    SELECT
        STRFTIME('%Y-%m', registration_date) AS registration_month,
        COUNT(customer_id) AS new_customers_count
    FROM Customers
    GROUP BY registration_month
)
SELECT
    registration_month,
    new_customers_count,
    SUM(new_customers_count) OVER (ORDER BY registration_month) AS cumulative_customers
FROM MonthlyRegistrations
ORDER BY registration_month ASC;`
                ));
                 if (isExerciseCompleted('chapter-10', 'chapter-10-exercise-10-2')) {
                    getElementById('chapter-10-exercise-10-2').style.border = '2px solid var(--primary-color)';
                }
            }

            setupEditorAndRunButton('exercise-editor-10-3', initialExercise10_3, 'exercise-results-10-3');
            const checkBtn10_3 = document.querySelector('button.check-answer-btn[data-exercise-id="chapter-10-exercise-10-3"]');
            if (checkBtn10_3) {
                checkBtn10_3.addEventListener('click', () => handleCheckAnswer(
                    'chapter-10-exercise-10-3',
                    'exercise-editor-10-3',
                    'exercise-results-10-3',
                    `SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    MIN(o.order_date) AS first_order_date,
    MAX(o.order_date) AS last_order_date
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY c.customer_id ASC;`
                ));
                 if (isExerciseCompleted('chapter-10', 'chapter-10-exercise-10-3')) {
                    getElementById('chapter-10-exercise-10-3').style.border = '2px solid var(--primary-color)';
                }
            }


            setupEditorThemeListener();
        });

        // Ensure editors resize when window resizes
        window.addEventListener('resize', () => {
            for (const editorId in editors) {
                if (editors[editorId]) {
                    editors[editorId].layout();
                }
            }
        });
    </script>
</body>
</html>
